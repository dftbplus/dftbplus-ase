#------------------------------------------------------------------------------#
#  DFTB+: general package for performing fast atomistic simulations            #
#  Copyright (C) 2006 - 2022  DFTB+ developers group                           #
#                                                                              #
#  See the LICENSE file for terms of usage and distribution.                   #
#------------------------------------------------------------------------------#

""" This module defines a FileIOCalculator for DFTB+

http://www.dftbplus.org/
http://www.dftb.org/

Initial development: markus.kaukonen@iki.fi
"""

import os
from io import StringIO
import copy
import numpy as np
from ase.calculators.calculator import (FileIOCalculator, kpts2ndarray,
                                        kpts2sizeandoffsets)
import hsd
import dftbplus_ptools.resultstag
from dftbplus_ptools.hsdinput import Hsdinput
from dftbplus_ase.calculator import DftbPlus
from ase.units import Hartree, Bohr


class Dftb(DftbPlus):
    """legacy calculator based on new dftbplus calculator"""

    discard_results_on_any_change = True

    def __init__(self, restart=None,
                 ignore_bad_restart_file=FileIOCalculator._deprecated,
                 label='dftb', atoms=None, kpts=None,
                 slako_dir=None,
                 **kwargs):
        """
        All keywords for the dftb_in.hsd input file (see the DFTB+ manual)
        can be set by ASE. Consider the following input file block:

        >>> Hamiltonian = DFTB {
        >>>     SCC = Yes
        >>>     SCCTolerance = 1e-8
        >>>     MaxAngularMomentum = {
        >>>         H = s
        >>>         O = p
        >>>     }
        >>> }

        This can be generated by the DFTB+ calculator by using the
        following settings:

        >>> calc = Dftb(Hamiltonian_='DFTB',  # line is included by default
        >>>             Hamiltonian_SCC='Yes',
        >>>             Hamiltonian_SCCTolerance=1e-8,
        >>>             Hamiltonian_MaxAngularMomentum_='',
        >>>             Hamiltonian_MaxAngularMomentum_H='s',
        >>>             Hamiltonian_MaxAngularMomentum_O='p')

        In addition to keywords specific to DFTB+, also the following keywords
        arguments can be used:

        restart: str
            Prefix for restart file.  May contain a directory.
            Default is None: don't restart.
        ignore_bad_restart_file: bool
            Ignore broken or missing restart file. By default, it is an
            error if the restart file is missing or broken.
        label: str (default 'dftb')
            Prefix used for the main output file (<label>.out).
        atoms: Atoms object (default None)
            Optional Atoms object to which the calculator will be
            attached. When restarting, atoms will get its positions and
            unit-cell updated from file.
        kpts: (default None)
            Brillouin zone sampling:

            * ``(1,1,1)`` or ``None``: Gamma-point only
            * ``(n1,n2,n3)``: Monkhorst-Pack grid
            * ``dict``: Interpreted as a path in the Brillouin zone if
              it contains the 'path_' keyword. Otherwise it is converted
              into a Monkhorst-Pack grid using
              ``ase.calculators.calculator.kpts2sizeandoffsets``
            * ``[(k11,k12,k13),(k21,k22,k23),...]``: Explicit (Nkpts x 3)
              array of k-points in units of the reciprocal lattice vectors
              (each with equal weight)

        Additional attribute to be set by the embed() method:

        pcpot: PointCharge object
            An external point charge potential (for QM/MM calculations)
        """
        if 'DFTB_COMMAND' in os.environ:
            command = os.environ['DFTB_COMMAND'] + ' > PREFIX.out'
        else:
            command = 'dftb+ > PREFIX.out'

        if slako_dir is None:
            slako_dir = os.environ.get('DFTB_PREFIX', './')
            if not slako_dir.endswith('/'):
                slako_dir += '/'

        self.slako_dir = slako_dir

        self.default_parameters = dict(
            Hamiltonian_='DFTB',
            Hamiltonian_SlaterKosterFiles_='Type2FileNames',
            Hamiltonian_SlaterKosterFiles_Prefix=self.slako_dir,
            Hamiltonian_SlaterKosterFiles_Separator='"-"',
            Hamiltonian_SlaterKosterFiles_Suffix='".skf"',
            Hamiltonian_MaxAngularMomentum_='',
            Options_='',
            Options_WriteResultsTag='Yes')

        FileIOCalculator.__init__(self, restart=restart, label=label,
                                  atoms=atoms, command=command,
                                  ignore_bad_restart_file=
                                  ignore_bad_restart_file, **kwargs)
        self._pcpot = None
        self._atoms = None
        self._atoms_input = None
        self._do_forces = False

        self.kpts = kpts
        self._old_kpts(atoms)
        fp = self._old_write_input(atoms)
        inp = hsd.load(fp, lower_tag_names=True)
        self._hsdinput = Hsdinput(dictionary=copy.deepcopy(inp))
        self._hamiltonian = self._hsdinput.get_hamiltonian()
        self._mmpositions = None


        # Determine number of spin channels
        try:
            spinpolkeys = list(self._hsdinput['hamiltonian']
                               [self._hamiltonian]['spinpolarisation'].keys())
            self.nspin = 2 if 'colinear' in spinpolkeys else 1
        except KeyError:
            self.nspin = 1


    def _old_kpts(self, atoms):
        self.kpts_coord = None

        if self.kpts is not None:
            initkey = 'Hamiltonian_KPointsAndWeights'
            mp_mesh = None
            offsets = None

            if isinstance(self.kpts, dict):
                if 'path' in self.kpts:
                    # kpts is path in Brillouin zone
                    self.parameters[initkey + '_'] = 'Klines '
                    self.kpts_coord = kpts2ndarray(self.kpts, atoms=atoms)
                else:
                    # kpts is (implicit) definition of
                    # Monkhorst-Pack grid
                    self.parameters[initkey + '_'] = 'SupercellFolding '
                    mp_mesh, offsets = kpts2sizeandoffsets(atoms=atoms,
                                                           **self.kpts)
            elif np.array(self.kpts).ndim == 1:
                # kpts is Monkhorst-Pack grid
                self.parameters[initkey + '_'] = 'SupercellFolding '
                mp_mesh = self.kpts
                offsets = [0.] * 3
            elif np.array(self.kpts).ndim == 2:
                # kpts is (N x 3) list/array of k-point coordinates
                # each will be given equal weight
                self.parameters[initkey + '_'] = ''
                self.kpts_coord = np.array(self.kpts)
            else:
                raise ValueError('Illegal kpts definition:' + str(self.kpts))

            if mp_mesh is not None:
                eps = 1e-10
                for i in range(3):
                    key = initkey + '_empty%03d' % i
                    val = [mp_mesh[i] if j == i else 0 for j in range(3)]
                    self.parameters[key] = ' '.join(map(str, val))
                    offsets[i] *= mp_mesh[i]
                    assert abs(offsets[i]) < eps or abs(offsets[i] - 0.5) < eps
                    # DFTB+ uses a different offset convention, where
                    # the k-point mesh is already Gamma-centered prior
                    # to the addition of any offsets
                    if mp_mesh[i] % 2 == 0:
                        offsets[i] += 0.5
                key = initkey + '_empty%03d' % 3
                self.parameters[key] = ' '.join(map(str, offsets))

            elif self.kpts_coord is not None:
                for i, c in enumerate(self.kpts_coord):
                    key = initkey + '_empty%09d' % i
                    c_str = ' '.join(map(str, c))
                    if 'Klines' in self.parameters[initkey + '_']:
                        c_str = '1 ' + c_str
                    else:
                        c_str += ' 1.0'
                    self.parameters[key] = c_str


    def _old_write_input(self, atoms):
        """ Write the input file for the dftb+ calculation.
            Geometry is taken always from the file 'geo_end.gen'.
        """
        from ase.io import write
        FileIOCalculator.write_input(self, atoms)
        write(os.path.join(self.directory, 'geo_end.gen'), atoms,
              parallel=False)
        # self._atoms is none until results are read out,
        # then it is set to the ones at writing input
        self._atoms_input = atoms
        self._atoms = None
        filestring = ('Geometry = GenFormat { \n')
        filestring += ('    <<< "geo_end.gen" \n')
        filestring += ('} \n')
        filestring += (' \n')

        params = self.parameters.copy()

        s = 'Hamiltonian_MaxAngularMomentum_'
        for key in params:
            if key.startswith(s) and len(key) > len(s):
                break
        else:
            # User didn't specify max angular mometa.  Get them from
            # the .skf files:
            symbols = set(self._atoms.get_chemical_symbols())
            for symbol in symbols:
                path = os.path.join(self.slako_dir,
                                    '{0}-{0}.skf'.format(symbol))
                l = read_max_angular_momentum(path)
                params[s + symbol] = '"{}"'.format('spdf'[l])

        # --------MAIN KEYWORDS-------
        previous_key = 'dummy_'
        myspace = ' '
        for key, value in sorted(params.items()):
            current_depth = key.rstrip('_').count('_')
            previous_depth = previous_key.rstrip('_').count('_')
            for my_backsclash in reversed(
                    range(previous_depth - current_depth)):
                filestring += (3 * (1 + my_backsclash) * myspace + '} \n')
            filestring += (3 * current_depth * myspace)
            if key.endswith('_') and len(value) > 0:
                filestring += (key.rstrip('_').rsplit('_')[-1] +
                               ' = ' + str(value) + '{ \n')
            elif (key.endswith('_') and (len(value) == 0)
                  and current_depth == 0):  # E.g. 'Options {'
                filestring += (key.rstrip('_').rsplit('_')[-1] +
                               ' ' + str(value) + '{ \n')
            elif (key.endswith('_') and (len(value) == 0)
                  and current_depth > 0):  # E.g. 'Hamiltonian_Max... = {'
                filestring += (key.rstrip('_').rsplit('_')[-1] +
                               ' = ' + str(value) + '{ \n')
            elif key.count('_empty') == 1:
                filestring += (str(value) + ' \n')
            elif ((key == 'Hamiltonian_ReadInitialCharges') and
                  (str(value).upper() == 'YES')):
                f1 = os.path.isfile(self.directory + os.sep + 'charges.dat')
                f2 = os.path.isfile(self.directory + os.sep + 'charges.bin')
                if not (f1 or f2):
                    print('charges.dat or .bin not found, switching off guess')
                    value = 'No'
                filestring += (key.rsplit('_')[-1] + ' = ' + str(value) +
                               ' \n')
            else:
                filestring += (key.rsplit('_')[-1] + ' = ' + str(value) +
                               ' \n')
            if self._pcpot is not None and ('DFTB' in str(value)):
                filestring += ('   ElectricField = { \n')
                filestring += ('      PointCharges = { \n')
                filestring += (
                    '         CoordsAndCharges [Angstrom] = DirectRead { \n')
                filestring += ('            Records = ' +
                               str(len(self._pcpot.mmcharges)) + ' \n')
                filestring += (
                    '            File = "dftb_external_charges.dat" \n')
                filestring += ('         } \n')
                filestring += ('      } \n')
                filestring += ('   } \n')
            previous_key = key
        current_depth = key.rstrip('_').count('_')
        for my_backsclash in reversed(range(current_depth)):
            filestring += (3 * my_backsclash * myspace + '} \n')
        filestring += ('ParserOptions { \n')
        filestring += ('   IgnoreUnprocessedNodes = Yes  \n')
        filestring += ('} \n')
        if self._do_forces:
            filestring += ('Analysis { \n')
            filestring += ('   CalculateForces = Yes  \n')
            filestring += ('} \n')
        return StringIO(filestring)


    def read_results(self):
        DftbPlus.read_results(self)
        self._mmpositions = None


    def check_state(self, atoms, tol=1e-15):
        """Check for any system changes since last calculation.

        Args:
            atoms (atoms object): atom to be compared to
            tol (float): tolerance for comparison

        Returns:
            system_changes (list): containing changed properties
        """
        system_changes = FileIOCalculator.check_state(self, atoms, tol=1e-15)
        # Ignore unit cell for molecules:
        if not atoms.pbc.any() and 'cell' in system_changes:
            system_changes.remove('cell')
        if self._pcpot and self._pcpot._mmpositions is not None:
            system_changes.append('positions')
        return system_changes


    def write_input(self, atoms, properties=None, system_changes=None):
        DftbPlus.write_input(self, atoms, properties, system_changes)
        if self._pcpot:
            self._pcpot.write_mmcharges('dftb_external_charges.dat')

    def read_forces(self):
        return self.get_property('forces').copy()


    def read_charges_energy_dipole(self):

        if 'charges' in self.results:
            charges = self.results['charges']
        else:
            charges = None

        if 'energy' in self.results:
            energy = self.results['energy']
        else:
            energy = None

        if 'dipole' in self.results:
            dipole = self.results['dipole']
        else:
            dipole = None

        return charges, energy, dipole


    def get_charges(self, atoms):
        """ Get the calculated charges
        this is inhereted to atoms object """
        if 'charges' in self.results:
            return self.results['charges']
        return None

    def read_eigenvalues(self):
        if 'eigenvalues' in self.results:
            return self.results['eigenvalues'].copy
        return None


    def read_fermi_levels(self):
        if 'fermi_levels' in self.results:
            return self.results['fermi_levels'].copy
        return None


    def get_ibz_k_points(self):
        return self.kpts_coord.copy()


    def embed(self, mmcharges=None, directory='./'):
        """Embed atoms in point-charges (mmcharges)."""

        self._pcpot = PointChargePotential(mmcharges, self.directory)
        return self._pcpot


class PointChargePotential:
    """Class for embedding atoms in point-charges (mmcharges)."""

    def __init__(self, mmcharges, directory='./'):
        """Point-charge potential for DFTB+."""

        self.mmcharges = mmcharges
        self.directory = directory
        self._mmpositions = None
        self.mmforces = None


    def set_positions(self, mmpositions):
        """Sets self._mmpositions"""
        self._mmpositions = mmpositions


    def set_charges(self, mmcharges):
        """Sets self.mmcharges"""
        self.mmcharges = mmcharges


    def write_mmcharges(self, filename='dftb_external_charges.dat'):
        """mok all
          Write external charges as monopoles for DFTB+.
        """

        if self.mmcharges is None:
            print('DFTB: Warning: not writing external charges ')
            return
        charge_file = open(os.path.join(self.directory, filename), 'w')
        for [pos, charge] in zip(self._mmpositions, self.mmcharges):
            [x, y, z] = pos
            charge_file.write('%12.6f %12.6f %12.6f %12.6f \n'
                              % (x, y, z, charge))
        charge_file.close()


    def get_forces(self, calc, get_forces=True):
        """Returns forces on point charges if the flag get_forces=True."""

        if get_forces:
            return self.read_forces_on_pointcharges()
        return np.zeros_like(self._mmpositions)


    def read_forces_on_pointcharges(self):
        """Read forces from DFTB+ output file (results.tag)."""
        path = os.path.join(self.directory, "results.tag")
        resultstag = dftbplus_ptools.resultstag.Output(path)

        return resultstag.get_forces_ext_charges() * Hartree / Bohr


def read_max_angular_momentum(path):
    return Hsdinput().read_max_angular_momentum(path=path)
